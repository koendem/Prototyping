// Name:ExprParser.jjt
// Date: 29 June 2016
//
// Definition of the ExprParser syntax. Includes abstract syntax tree generation
//

options
{
  LOOKAHEAD=2;
  IGNORE_CASE = false;
  MULTI=true;
  VISITOR = true;
  STATIC=false;
  NODE_CLASS="com.silvermoongroup.navexpressionparser.NavExpressionSimpleNode";
}

PARSER_BEGIN(ExprParser)
package com.silvermoongroup.navexpressionparser;

import java.io.*;
import java.util.*;


public class ExprParser
{



}

PARSER_END(ExprParser)

TOKEN_MGR_DECLS:
{

}

SKIP:   /* Whitespace */
{
  "\t"
| "\n"
| "\r"

}

TOKEN:
{
  <CONCAT: ".">
| <LITERAL: "\"" (["a"-"z","A"-"Z","0"-"9", " ", "<", ">", "&","/","'",".","-"])+ "\"" >
| <TOPLEVELAGREEMENT: "topLevelAgreement">
| <REQUEST: "request">
| <CHILDREN: "children">
| <DESCENDANTS: "descendants">
| <INSTANCEOF: "instanceOf">
| <ALL: "all">
| <EXPRESSIONSTEP: ((["a"-"z","A"-"Z","0"-"9"])+  | ("\'" (["a"-"z","A"-"Z","0"-"9"," "])+  "\'")
             ) >
| <SEMIC: ";">
| <LPAREN: "(">
| <RPAREN: ")">
}


/* production rules for the language.
navPathExpression =
              <LITERAL>
              | <TOPLEVELAGREEMENT> [<CONCAT> compoundNavigation]
              | <REQUEST> [<CONCAT> compoundNavigation]
              | compoundNavigation


compoundNavigation = kindNavigation [ <SEMIC> domainNavigation ]


kindNavigation = navigationStep() [ <CONCAT> kindNavigation ]

navigationStep = <KINDSTEP>

type = <KINDSTEP>

doaminNavigation = navigationStep() [ <CONCAT> domainNavigation ]


children = <CHILDREN> <LPAREN> navigationStep() <RPAREN>

descendants = <DESCENDANTS> <LPAREN> navigationStep() <RPAREN>

instanceOf = <INSTANCEOF> <LPAREN> type() <RPAREN>
*/

SimpleNode navPathExpression() : {}
{
 (     (literal())
     | ( topLevelAgreement() [ <CONCAT> compoundNavigation()])
     | ( request() [ <CONCAT> compoundNavigation()])
     | (compoundNavigation())
 ) {return jjtThis;}
}


void topLevelAgreement() : {Token t;}
{
 t= <TOPLEVELAGREEMENT> {jjtThis.value = t.image;}
}

void request() : {Token t;}
{
 t= <REQUEST> {jjtThis.value = t.image;}
}

void literal() : { Token t; }
{
    t = <LITERAL> {jjtThis.value = t.image; }
}

void compoundNavigation() #void : {Token t;}
{
  (kindNavigation()) [ (domainNavigation()) ]
}

void all() : {Token t;}
{
 (t = <ALL> {jjtThis.value = t.image;} )
}

void children() : {}
{
  <CHILDREN> <LPAREN> navigationStep() <RPAREN>
}

void descendants() : {}
{
  <DESCENDANTS> <LPAREN> navigationStep() <RPAREN>
}
void instanceOf() : {}
{
  <INSTANCEOF> <LPAREN> type() <RPAREN>
}
void kindNavigation() #void : {}
{
    (navigationStep()
    | all()
    | children()
    | descendants()
	| instanceOf()
    )  [ <CONCAT> kindNavigation() ]
}

void navigationStep() : {Token t; }
{
  t = <EXPRESSIONSTEP> {jjtThis.value = t.image; }
}

void type() : {Token t; }
{
  t = <EXPRESSIONSTEP> {jjtThis.value = t.image; }
}

void domainNavigation() : {}
{
    <SEMIC> domainNavigations()
}

void domainNavigations() #void : {}
{
    (kindNavigation())  [ <CONCAT> domainNavigations() ]
}



